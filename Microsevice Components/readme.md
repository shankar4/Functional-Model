I will document my summary of "The Tao of Microservices" by Richard Rodger, Manning, 2018. App code developed will be included here. The author (via Manning) provides code for download also. Here is the [Github](https://github.com/senecajs/ramanujan) site. One of his app servers is [here](http://nodezoo.com/#q=). For an overview of the field, visit his [site](https://microservices.io/). He also recommends Martin Fowlwer's [site](https://martinfowler.com/microservices/). 

The author has a new twist on the traditional definition of microserices. He sees them as a natural evolution of the quest for software components that actually work. 

James Lewis and Martin Fowler have defined microservices thus: "....is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies." As per Martin Fowler, common characteristics of microservices are: Componentization via Services, Organized around Business Capabilities, Products not Projects, Smart endpoints and dumb pipes, Decentralized Governance, Decentralized Data Management, Infrastructure Automation, Design for failure, and Evolutionary Design. ABenefits are: strong modular boundaries, independent module deployment, and technology diversity. However, these come at the expense of: distributed systems (harder to code and risk slow remote calls and points of failure), eventual consistency (need to manage it locally), and operational complexity (many of the services are deployed regularly. Need a good technical operations team to manage). Fowler talks of a **Microservices Premium** which is high for simple systems, in terms of lost productivity. However, if the system is complex enough, productivity improvement and reduced maintenance accrue. 

The [microservice architecture pattern language](https://microservices.io/) aims to help us decide whether microservices are right for the application and if so, deploy it successfully. Start with the [Monolithic Architecture Pattern](https://microservices.io/patterns/monolithic.html). If it is not appropriate, especially for a large/complex system, then move to the [Microservice Architecture Pattern](https://microservices.io/patterns/microservices.html). 

The author frames the need for microservices in terms of the technical debt crisis: Changing requirements in the middle of a project damage the original software architecture, causing unforeseen changes and fixes, which will significantly delay the software development process. Can't blame on our nontechnical colleagues - they have complex challenges of their own. It's time to grow up and accept that we have a problem: can't write software fast enough. He suggests that components are being built to address technical infrastructure, not the business logic. Components like that would speed up development. Our components tend to be comprehensive in functionality and they are difficult to compose them together - will need lots of glue code. By trying to cover too many cases, we make the simple ones too complex. *Business logic* is the functionality that's directly specific to the business goal at hand. Eg., user-profile management. It is specific to the programming language, not generic. Composition is powerful - don't modify components; instead, write new ones to handle special cases. As a solution, components should be working, but they aren't. Microservices built the right way, can help do that. 



