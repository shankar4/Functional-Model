I will summarize some books on SystemC here: System Design with SystemC, Grotker et al., Kluwer, 2002. 

According to [Wikipedia](https://en.wikipedia.org/wiki/Transistor_count), as of 2017, there are 19.2 billion transistors in AMD's Ryzen-based Epyc, fabricated with a 14 nm process and to a chip size of 4 x 192 m<sup>2</sup>.  Compare this to AMD K10 in 2008 at 0.8 billion transistors with a 45 nm process and a chip size of 258 mm<sup>2</sup>. Among FPGAs, Intel's  Stratix 10 has over 30 billion transistors. Complexity is enormous and continues to dramatically increase. It is the job of the engineering design automation (EDA) industry to manage complexity and help companies deliver new systems at a rapid pace. The Time-to-market today hovers around 18 months, with the time-in-market around 1 year, with ever incresing demand for smaller product size, lower power, and higher speed, and integration of analog and other mixed signal systems (such as MEMS, RF, and sensors). 

A modern SOC (system-on-a-chip)  may contain multiple processors (microcontrollers, DSPs, media processors, etc),  on-chip memory, dedicated hardware accelerators, and periperhal controllers, along with complex on-chip communication networks, and a software stack. To specify, design, and implement such complex systems, and incorporate functionality implemented in both hardware and software, a system-level language, quite unlike the HDLs (hardware description languages) of the old, is needed. Such a language **must support**: specification and design at various levels of abstraction, Incorporation of embedded software at both model and implementation level, creation of executable specifications of design intent, creation of executable platform models, fast simulation speed to enable design space exploration, and separation of computation and communication functionality to allow reuse of both models and implementations. Also, this language should be based on a well-established programming language, so as to capitalize on the **extensive infrastructure** of capture, compilation,and debugging tools already available. An object oriented language would allow for modeling flexibility and code reuse, through templates, inheritance, etc. C++ was determined to be a good choice for a new language to build on (though a bit hard to learn; Java was considered less mature at the time of this decision, viz., around 2000). Absence of a standardized and well-accepted system-level language has impacted the development, exchange, and reuse of IP models at the system level. RT level IP is usually written  at the RTL level of HDLs, with implementation in mind, which inhibits design exploration, and is relatively poor in IP protection. RT level models also simulate slowly compared to more abstract models. The Virtual Socket Interface Alliance (VSIA) has defined a system level interface (SLIF) that facilitates IP exchange at the system level. In **summary**, SystemC provides a modeling framework for systems in which high-level functional models can be refined down to implementation in a single language. SystemC 2.0 effort (from around 2000-2001) led to improved models of time, dynamic sensitivity, user defined interfaces, channels and ports, with primitive and hierarchical channels, as well as restructuring separting the core of the language from methodology-specific libraries. 

SystemC does allows for one to mix and match modules at various levels of abstraction (behavioral to RTL). Design flows are iterative. A model's accuracy has these dimensions: (1) structural accuracy - of the actual software-hardware partition and their hierarchies; (2) timing accuracy - model should reflect the timing of the actual implementation. Higher level hardware models only care about timing at the clock-cycle level; (3) functional accuracy: A high-level model may omit certain complex functionality to simplify the model or increase simulation speed, but maintain overall functionality. E.g., DSP blocks are initially modeled with floating-point data-types and arithmetic. After fucntional verification, the functional model is refined to bit-accurate model to accurately capture effects of fixed-precision data-types and arithmetic; (4) Data-organization accuracy; (5) communication protocol accuracy - in more abstract level models, details may be omitted to achieve higher modeling speed. 

Different modeling levels: An *executable specification* is a direct translation of a design spec into SystemC. This is completely independent of any proposed implementation. Timing delays, if any, are timing constraints to be imposed on the implementation. An *untimed functional model* is similar to an executable spec, but no time delays are present. communication between modules is point-to-point (i.e., no shared communication links, such as buses, are modeled). Communication is usually modeled using FIFOs with blocking write and read so data items are reliably delivered between modules. A *timed functional model* is similar to an untimed functional model in terms of its point-to-point communication and synchronous FIFO.  However, in a timed functional model, timing delays are added to reflect timing constraints, process and communication delays. Such models are useful for early software-hardware trade-off analysis. Mapping to various combinations of software and hardware will yield different delay figures. *Note*: None of the above models has any direct structural correspondence to a target implementation. 
